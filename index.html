<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>For You â€” A Valentine's Rose</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Great+Vibes&family=Poppins:wght@300;400;600&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      overflow: hidden;
      background: #0a0000;
      font-family: 'Poppins', sans-serif;
      -webkit-tap-highlight-color: transparent;
    }

    canvas { display: block; }

    /* â”€â”€ Reveal overlay â”€â”€ */
    #reveal-overlay {
      position: fixed; inset: 0;
      z-index: 100;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      background: radial-gradient(ellipse at center, #1a0008 0%, #0a0000 100%);
      transition: opacity 1.2s ease, visibility 1.2s ease;
    }
    #reveal-overlay.hidden {
      opacity: 0; visibility: hidden; pointer-events: none;
    }

    #reveal-overlay h1 {
      font-family: 'Great Vibes', cursive;
      font-size: clamp(2.2rem, 7vw, 4.5rem);
      color: #ff4f7b;
      text-shadow: 0 0 30px rgba(255,79,123,.5);
      margin-bottom: 0.3em;
      opacity: 0; animation: fadeUp .8s .2s forwards;
    }
    #reveal-overlay p {
      font-size: clamp(.9rem, 2.5vw, 1.15rem);
      color: rgba(255,200,210,.7);
      margin-bottom: 2.5em;
      opacity: 0; animation: fadeUp .8s .5s forwards;
    }

    #reveal-btn {
      position: relative;
      padding: 18px 54px;
      font-family: 'Poppins', sans-serif;
      font-size: clamp(1rem, 2.8vw, 1.2rem);
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, #e8365d 0%, #d4145a 50%, #c2185b 100%);
      border: none; border-radius: 60px;
      cursor: pointer;
      box-shadow:
        0 0 25px rgba(232,54,93,.45),
        0 0 80px rgba(232,54,93,.2);
      overflow: hidden;
      opacity: 0; animation: fadeUp .8s .8s forwards;
      transition: transform .25s, box-shadow .25s;
    }
    #reveal-btn:hover {
      transform: scale(1.06);
      box-shadow:
        0 0 40px rgba(232,54,93,.6),
        0 0 120px rgba(232,54,93,.3);
    }
    #reveal-btn:active { transform: scale(.97); }

    #reveal-btn .shimmer {
      position: absolute; inset: 0;
      background: linear-gradient(110deg, transparent 30%, rgba(255,255,255,.25) 50%, transparent 70%);
      animation: shimmer 2.5s infinite;
    }

    /* â”€â”€ Floating hearts background on overlay â”€â”€ */
    .heart-bg { position: fixed; inset: 0; z-index: 99; pointer-events: none; }
    .heart-bg.hidden { display: none; }
    .heart-bg span {
      position: absolute; bottom: -40px;
      font-size: 20px; opacity: .35;
      animation: floatHeart linear infinite;
    }

    /* â”€â”€ Valentine message after reveal â”€â”€ */
    #message {
      position: fixed; bottom: 28px;
      width: 100%; text-align: center;
      z-index: 10; pointer-events: none;
      opacity: 0; transition: opacity 1.5s 1s ease;
    }
    #message.show { opacity: 1; }
    #message h2 {
      font-family: 'Great Vibes', cursive;
      font-size: clamp(1.6rem, 5vw, 3rem);
      color: #ff6b8a;
      text-shadow: 0 0 20px rgba(255,107,138,.4);
    }
    #message p {
      font-size: clamp(.75rem, 2vw, .95rem);
      color: rgba(255,180,195,.55);
      margin-top: 4px;
    }

    /* â”€â”€ Petal rain â”€â”€ */
    .petal-container { position: fixed; inset: 0; z-index: 5; pointer-events: none; }
    .petal {
      position: absolute; top: -30px;
      width: 14px; height: 18px;
      background: radial-gradient(ellipse at 30% 30%, #ff7b9e, #d4145a);
      border-radius: 50% 50% 50% 0;
      opacity: 0;
      animation: petalFall linear forwards;
    }

    /* â”€â”€ Controls hint â”€â”€ */
    #controls-hint {
      position: fixed; top: 18px; left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      font-size: .75rem;
      color: rgba(255,200,210,.35);
      pointer-events: none;
      opacity: 0; transition: opacity 1s 2s ease;
    }
    #controls-hint.show { opacity: 1; }

    /* â”€â”€ Keyframes â”€â”€ */
    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(24px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    @keyframes shimmer {
      0%   { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    @keyframes floatHeart {
      0%   { transform: translateY(0) rotate(0deg) scale(1); opacity: .35; }
      50%  { opacity: .5; }
      100% { transform: translateY(-110vh) rotate(360deg) scale(.5); opacity: 0; }
    }
    @keyframes petalFall {
      0%   { opacity: .85; transform: translateY(0) rotate(0deg) translateX(0); }
      100% { opacity: 0;   transform: translateY(110vh) rotate(720deg) translateX(80px); }
    }
  </style>
</head>
<body>

  <!-- Reveal Overlay -->
  <div id="reveal-overlay">
    <h1>Happy Valentine's Day</h1>
    <p>I made something special for you&hellip;</p>
    <button id="reveal-btn">
      <span class="shimmer"></span>
      Reveal Your Rose
    </button>
  </div>
  <div class="heart-bg" id="heart-bg"></div>

  <!-- 3D Canvas inserted by Three.js -->
  <div id="message">
    <h2>A Rose for You</h2>
    <p>Every petal holds my love</p>
  </div>
  <div id="controls-hint">Drag to rotate &middot; Pinch / scroll to zoom</div>
  <div class="petal-container" id="petal-container"></div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
  (() => {
    /* â”€â”€â”€ Floating hearts on overlay â”€â”€â”€ */
    const heartBg = document.getElementById('heart-bg');
    for (let i = 0; i < 25; i++) {
      const s = document.createElement('span');
      s.textContent = ['â¤','ðŸ’•','â™¥','ðŸ’—'][Math.floor(Math.random()*4)];
      s.style.left = Math.random()*100 + '%';
      s.style.fontSize = (14 + Math.random()*18) + 'px';
      s.style.animationDuration = (6 + Math.random()*8) + 's';
      s.style.animationDelay = Math.random()*6 + 's';
      heartBg.appendChild(s);
    }

    /* â”€â”€â”€ Three.js Scene â”€â”€â”€ */
    const scene  = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0000, 0.025);

    const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(0, 2, 7);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.insertBefore(renderer.domElement, document.body.firstChild);

    /* â”€â”€â”€ Lights â”€â”€â”€ */
    const ambient = new THREE.AmbientLight(0xffccdd, 0.35);
    scene.add(ambient);

    const keyLight = new THREE.DirectionalLight(0xffe0e8, 1.8);
    keyLight.position.set(5, 8, 5);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(1024, 1024);
    scene.add(keyLight);

    const rimLight = new THREE.PointLight(0xff2255, 1.2, 20);
    rimLight.position.set(-4, 3, -3);
    scene.add(rimLight);

    const fillLight = new THREE.PointLight(0xffaacc, 0.6, 15);
    fillLight.position.set(3, 0, 4);
    scene.add(fillLight);

    const bottomGlow = new THREE.PointLight(0xff1744, 0.4, 8);
    bottomGlow.position.set(0, -2, 0);
    scene.add(bottomGlow);

    /* â”€â”€â”€ Materials â”€â”€â”€ */
    const petalMat = new THREE.MeshStandardMaterial({
      color: 0xcc1140,
      roughness: 0.45,
      metalness: 0.08,
      side: THREE.DoubleSide,
      emissive: 0x330011,
      emissiveIntensity: 0.15,
    });
    const petalMatInner = new THREE.MeshStandardMaterial({
      color: 0xe8365d,
      roughness: 0.35,
      metalness: 0.05,
      side: THREE.DoubleSide,
      emissive: 0x440015,
      emissiveIntensity: 0.2,
    });
    const stemMat = new THREE.MeshStandardMaterial({
      color: 0x1b5e20,
      roughness: 0.6,
      metalness: 0.05,
    });
    const leafMat = new THREE.MeshStandardMaterial({
      color: 0x2e7d32,
      roughness: 0.5,
      metalness: 0.05,
      side: THREE.DoubleSide,
    });
    const sepalMat = new THREE.MeshStandardMaterial({
      color: 0x33691e,
      roughness: 0.55,
      metalness: 0.05,
      side: THREE.DoubleSide,
    });

    /* â”€â”€â”€ Rose group â”€â”€â”€ */
    const roseGroup = new THREE.Group();
    scene.add(roseGroup);

    /* â”€â”€ Helper: create a petal shape â”€â”€ */
    function createPetalGeometry(w, h, curl, segments) {
      const seg = segments || 16;
      const geo = new THREE.PlaneGeometry(w, h, seg, seg);
      const pos = geo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const ny = (y + h/2) / h; // 0 at bottom, 1 at top
        const nx = x / (w/2);     // -1 to 1

        // Curl the petal outward at the top
        const curlAmount = curl * ny * ny;
        const z = curlAmount * (1 - nx*nx) * 0.6;

        // Slight wavy edge
        const wave = Math.sin(nx * Math.PI * 3) * 0.04 * ny;

        // Cupping: raise edges
        const cup = nx * nx * 0.15 * (1 - ny);

        pos.setZ(i, z + wave + cup);
      }
      geo.computeVertexNormals();
      return geo;
    }

    /* â”€â”€ Build rose head â”€â”€ */
    const headGroup = new THREE.Group();
    headGroup.position.y = 2.8;

    // Inner petals â€” tightly spiraled
    const innerCount = 8;
    for (let i = 0; i < innerCount; i++) {
      const angle = (i / innerCount) * Math.PI * 2 + Math.random() * 0.15;
      const geo = createPetalGeometry(0.5, 0.8, 0.6, 12);
      const petal = new THREE.Mesh(geo, petalMatInner);
      petal.rotation.x = -Math.PI/2 + 0.6 + Math.random()*0.15;
      petal.rotation.z = angle;
      petal.rotation.y = Math.random()*0.1;
      petal.position.y = 0.15;
      const wrapper = new THREE.Group();
      wrapper.add(petal);
      wrapper.rotation.y = angle;
      headGroup.add(wrapper);
    }

    // Middle petals
    const midCount = 12;
    for (let i = 0; i < midCount; i++) {
      const angle = (i / midCount) * Math.PI * 2 + 0.3;
      const geo = createPetalGeometry(0.8, 1.1, 0.9, 14);
      const petal = new THREE.Mesh(geo, petalMat);
      petal.rotation.x = -Math.PI/2 + 0.35 + Math.random()*0.1;
      petal.position.y = 0.05;
      petal.position.z = 0.18;
      const wrapper = new THREE.Group();
      wrapper.add(petal);
      wrapper.rotation.y = angle;
      headGroup.add(wrapper);
    }

    // Outer petals â€” wide & curved back
    const outerCount = 14;
    for (let i = 0; i < outerCount; i++) {
      const angle = (i / outerCount) * Math.PI * 2 + 0.15;
      const geo = createPetalGeometry(1.1, 1.4, 1.3, 16);
      const petal = new THREE.Mesh(geo, petalMat);
      petal.rotation.x = -Math.PI/2 + 0.1 + Math.random()*0.08;
      petal.position.y = -0.1;
      petal.position.z = 0.35;
      const wrapper = new THREE.Group();
      wrapper.add(petal);
      wrapper.rotation.y = angle;
      headGroup.add(wrapper);
    }

    // Outermost petals â€” slightly drooping
    const outermost = 10;
    for (let i = 0; i < outermost; i++) {
      const angle = (i / outermost) * Math.PI * 2 + 0.5;
      const geo = createPetalGeometry(1.25, 1.5, 1.6, 16);
      const petal = new THREE.Mesh(geo, petalMat);
      petal.rotation.x = -Math.PI/2 - 0.1 + Math.random()*0.06;
      petal.position.y = -0.2;
      petal.position.z = 0.5;
      const wrapper = new THREE.Group();
      wrapper.add(petal);
      wrapper.rotation.y = angle;
      headGroup.add(wrapper);
    }

    roseGroup.add(headGroup);

    /* â”€â”€ Sepals â”€â”€ */
    const sepalCount = 5;
    for (let i = 0; i < sepalCount; i++) {
      const angle = (i / sepalCount) * Math.PI * 2;
      const geo = createPetalGeometry(0.35, 1.0, 0.5, 10);
      const sepal = new THREE.Mesh(geo, sepalMat);
      sepal.rotation.x = -Math.PI/2 - 0.4;
      sepal.position.z = 0.15;
      const wrapper = new THREE.Group();
      wrapper.add(sepal);
      wrapper.rotation.y = angle;
      wrapper.position.y = 2.2;
      roseGroup.add(wrapper);
    }

    /* â”€â”€ Stem â”€â”€ */
    const stemCurve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(0, -2.5, 0),
      new THREE.Vector3(0.05, -1.5, 0.05),
      new THREE.Vector3(-0.05, -0.5, -0.05),
      new THREE.Vector3(0.03, 0.5, 0.03),
      new THREE.Vector3(0, 1.5, 0),
      new THREE.Vector3(0, 2.3, 0),
    ]);
    const stemGeo = new THREE.TubeGeometry(stemCurve, 32, 0.06, 8, false);
    const stem = new THREE.Mesh(stemGeo, stemMat);
    roseGroup.add(stem);

    /* â”€â”€ Thorns â”€â”€ */
    const thornGeo = new THREE.ConeGeometry(0.025, 0.18, 6);
    const thornPositions = [0.2, 0.35, 0.5, 0.65, 0.78];
    thornPositions.forEach((t, idx) => {
      const pt = stemCurve.getPoint(t);
      const thorn = new THREE.Mesh(thornGeo, stemMat);
      thorn.position.copy(pt);
      thorn.rotation.z = (idx % 2 === 0 ? 1 : -1) * 1.2;
      thorn.position.x += (idx % 2 === 0 ? 0.08 : -0.08);
      roseGroup.add(thorn);
    });

    /* â”€â”€ Leaves â”€â”€ */
    function createLeaf(scale) {
      const shape = new THREE.Shape();
      shape.moveTo(0, 0);
      shape.bezierCurveTo(0.15*scale, 0.4*scale, 0.4*scale, 0.6*scale, 0, 1.0*scale);
      shape.bezierCurveTo(-0.4*scale, 0.6*scale, -0.15*scale, 0.4*scale, 0, 0);
      const geo = new THREE.ShapeGeometry(shape, 12);
      // slight bend
      const pos = geo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const y = pos.getY(i);
        const ny = y / (1.0 * scale);
        pos.setZ(i, Math.sin(ny * Math.PI) * 0.08 * scale);
      }
      geo.computeVertexNormals();
      return geo;
    }

    // Leaf 1
    const leaf1Geo = createLeaf(1.2);
    const leaf1 = new THREE.Mesh(leaf1Geo, leafMat);
    const leaf1Pt = stemCurve.getPoint(0.35);
    leaf1.position.copy(leaf1Pt);
    leaf1.position.x += 0.15;
    leaf1.rotation.z = -0.8;
    leaf1.rotation.y = 0.3;
    roseGroup.add(leaf1);

    // Leaf 2
    const leaf2Geo = createLeaf(1.0);
    const leaf2 = new THREE.Mesh(leaf2Geo, leafMat);
    const leaf2Pt = stemCurve.getPoint(0.55);
    leaf2.position.copy(leaf2Pt);
    leaf2.position.x -= 0.15;
    leaf2.rotation.z = 0.9;
    leaf2.rotation.y = -0.4;
    roseGroup.add(leaf2);

    // Leaf 3
    const leaf3Geo = createLeaf(0.8);
    const leaf3 = new THREE.Mesh(leaf3Geo, leafMat);
    const leaf3Pt = stemCurve.getPoint(0.7);
    leaf3.position.copy(leaf3Pt);
    leaf3.position.x += 0.12;
    leaf3.position.z += 0.1;
    leaf3.rotation.z = -0.7;
    leaf3.rotation.y = 0.6;
    roseGroup.add(leaf3);

    /* â”€â”€ Particle sparkles â”€â”€ */
    const sparkleCount = 120;
    const sparkleGeo = new THREE.BufferGeometry();
    const sparklePos = new Float32Array(sparkleCount * 3);
    const sparkleSizes = new Float32Array(sparkleCount);
    for (let i = 0; i < sparkleCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const r = 0.8 + Math.random() * 2.5;
      sparklePos[i*3]   = Math.cos(theta) * r;
      sparklePos[i*3+1] = (Math.random() - 0.3) * 5;
      sparklePos[i*3+2] = Math.sin(theta) * r;
      sparkleSizes[i] = 0.02 + Math.random() * 0.05;
    }
    sparkleGeo.setAttribute('position', new THREE.BufferAttribute(sparklePos, 3));
    sparkleGeo.setAttribute('size', new THREE.BufferAttribute(sparkleSizes, 1));

    const sparkleMat = new THREE.PointsMaterial({
      color: 0xff6b8a,
      size: 0.06,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true,
    });
    const sparkles = new THREE.Points(sparkleGeo, sparkleMat);
    roseGroup.add(sparkles);

    /* â”€â”€â”€ Camera controls (simple orbit) â”€â”€â”€ */
    let isDragging = false;
    let prevX = 0, prevY = 0;
    let rotY = 0, rotX = 0.3;
    let targetRotY = 0, targetRotX = 0.3;
    let camDist = 7, targetDist = 7;

    function onPointerDown(e) {
      isDragging = true;
      const p = e.touches ? e.touches[0] : e;
      prevX = p.clientX; prevY = p.clientY;
    }
    function onPointerMove(e) {
      if (!isDragging) return;
      const p = e.touches ? e.touches[0] : e;
      const dx = p.clientX - prevX;
      const dy = p.clientY - prevY;
      targetRotY += dx * 0.005;
      targetRotX += dy * 0.005;
      targetRotX = Math.max(-0.8, Math.min(1.2, targetRotX));
      prevX = p.clientX; prevY = p.clientY;
    }
    function onPointerUp() { isDragging = false; }

    function onWheel(e) {
      targetDist += e.deltaY * 0.005;
      targetDist = Math.max(3, Math.min(14, targetDist));
    }

    // Pinch zoom
    let pinchDist = 0;
    function onTouchStart(e) {
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        pinchDist = Math.sqrt(dx*dx + dy*dy);
      } else {
        onPointerDown(e);
      }
    }
    function onTouchMove(e) {
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        targetDist -= (dist - pinchDist) * 0.015;
        targetDist = Math.max(3, Math.min(14, targetDist));
        pinchDist = dist;
      } else {
        onPointerMove(e);
      }
    }

    renderer.domElement.addEventListener('mousedown', onPointerDown);
    renderer.domElement.addEventListener('mousemove', onPointerMove);
    renderer.domElement.addEventListener('mouseup', onPointerUp);
    renderer.domElement.addEventListener('mouseleave', onPointerUp);
    renderer.domElement.addEventListener('wheel', onWheel, { passive: true });
    renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: true });
    renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: true });
    renderer.domElement.addEventListener('touchend', onPointerUp);

    /* â”€â”€â”€ Resize â”€â”€â”€ */
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* â”€â”€â”€ Reveal logic â”€â”€â”€ */
    let revealed = false;
    roseGroup.scale.set(0, 0, 0);

    document.getElementById('reveal-btn').addEventListener('click', () => {
      revealed = true;
      document.getElementById('reveal-overlay').classList.add('hidden');
      document.getElementById('heart-bg').classList.add('hidden');
      document.getElementById('message').classList.add('show');
      document.getElementById('controls-hint').classList.add('show');
      spawnPetals();
    });

    /* â”€â”€ Falling petals â”€â”€ */
    function spawnPetals() {
      const container = document.getElementById('petal-container');
      for (let i = 0; i < 35; i++) {
        const petal = document.createElement('div');
        petal.className = 'petal';
        petal.style.left = Math.random() * 100 + '%';
        petal.style.animationDuration = (3 + Math.random() * 4) + 's';
        petal.style.animationDelay = (Math.random() * 3) + 's';
        const s = 0.6 + Math.random() * 0.8;
        petal.style.transform = `scale(${s})`;
        petal.style.borderRadius = `${50+Math.random()*20}% ${50+Math.random()*20}% ${50+Math.random()*20}% 0`;
        container.appendChild(petal);
      }
      // Clean up after animation
      setTimeout(() => { container.innerHTML = ''; }, 8000);
    }

    /* â”€â”€â”€ Animation loop â”€â”€â”€ */
    const clock = new THREE.Clock();
    let revealProgress = 0;

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      const dt = clock.getDelta();

      // Smooth orbit
      rotY += (targetRotY - rotY) * 0.06;
      rotX += (targetRotX - rotX) * 0.06;
      camDist += (targetDist - camDist) * 0.06;

      // Auto-rotate gently
      if (!isDragging) {
        targetRotY += 0.002;
      }

      camera.position.x = Math.sin(rotY) * Math.cos(rotX) * camDist;
      camera.position.y = Math.sin(rotX) * camDist + 1.5;
      camera.position.z = Math.cos(rotY) * Math.cos(rotX) * camDist;
      camera.lookAt(0, 1.5, 0);

      // Reveal scale animation
      if (revealed && revealProgress < 1) {
        revealProgress = Math.min(1, revealProgress + 0.012);
        // Elastic ease out
        const p = revealProgress;
        const ease = p === 1 ? 1 : 1 - Math.pow(2, -10 * p) * Math.cos((p * 10 - 0.75) * (2 * Math.PI / 3));
        roseGroup.scale.setScalar(ease);
      }

      // Gentle sway
      if (revealed) {
        headGroup.rotation.x = Math.sin(t * 0.5) * 0.02;
        headGroup.rotation.z = Math.cos(t * 0.7) * 0.015;
      }

      // Sparkle animation
      const sp = sparkleGeo.attributes.position;
      for (let i = 0; i < sparkleCount; i++) {
        sp.setY(i, sp.getY(i) + Math.sin(t * 2 + i) * 0.001);
      }
      sp.needsUpdate = true;
      sparkleMat.opacity = 0.3 + Math.sin(t * 1.5) * 0.2;

      // Light pulse
      rimLight.intensity = 1.0 + Math.sin(t * 1.2) * 0.3;

      renderer.render(scene, camera);
    }

    animate();
  })();
  </script>
</body>
</html>
